(() => {
  const startBtn = document.getElementById('startBtn');
  const slots = Array.from(document.querySelectorAll('.slot'));
  const deckEl = document.getElementById('deck');
  // Ensure back image fallback for slot backs
  Array.from(document.querySelectorAll('.face.back img')).forEach(img => {
    img.onerror = () => { img.src = BLANK_DATA_URI; };
  });

  function shuffle(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function drawThree() {
    const deck = shuffle(TAROT_CARDS);
    const picks = deck.slice(0, 3).map(c => ({
      ...c,
      reversed: Math.random() < 0.5
    }));
    return picks; // [past, present, future]
  }

  function buildPositionText(card, pos, reversed) {
    const base = reversed ? card.meaning.rev : card.meaning.up;
    const posLabel = pos === 'past' ? '過去' : pos === 'present' ? '現在' : '未来';
    // Lightly position-specific phrasing using the base meaning
    const prefix = {
      past: '過去では',
      present: '現在は',
      future: '未来では'
    }[pos];
    return `${prefix}${reversed ? '（逆位置）' : '（正位置）'}「${base}」のテーマが表れています。`;
  }

  function setCardFace(slotEl, card, reversed) {
    const cardEl = slotEl.querySelector('.card');
    const imgEl = slotEl.querySelector('.face.front img');
    const infoEl = slotEl.querySelector('.info');

    // Reset classes
    cardEl.classList.remove('revealed', 'reversed');

    // Set image with fallback
    imgEl.onload = null;
    imgEl.onerror = () => {
      imgEl.src = BLANK_DATA_URI;
    };
    imgEl.src = `../img/${card.file}`;

    // Reveal animation with a tiny timeout to ensure DOM applied
    requestAnimationFrame(() => {
      setTimeout(() => {
        cardEl.classList.add('revealed');
        if (reversed) cardEl.classList.add('reversed');
      }, 30);
    });

    // Info text
    const pos = slotEl.getAttribute('data-pos');
    const oriLabel = reversed ? '逆位置' : '正位置';
    const posLabel = pos === 'past' ? '過去' : pos === 'present' ? '現在' : '未来';
    const text = buildPositionText(card, pos, reversed);
    infoEl.innerHTML = `<span class="name">${card.name} / ${card.en}</span><span class="ori">${oriLabel}</span>\n${posLabel}: ${text}`;
  }

  // Delayed reveal version: keeps back visible until arrival, then flips and shows text
  function setCardFaceDelayed(slotEl, card, reversed, revealDelayMs = 180) {
    const cardEl = slotEl.querySelector('.card');
    const imgEl = slotEl.querySelector('.face.front img');
    const infoEl = slotEl.querySelector('.info');

    cardEl.classList.remove('revealed', 'reversed');

    imgEl.onload = null;
    imgEl.onerror = () => { imgEl.src = BLANK_DATA_URI; };
    imgEl.src = `../img/${card.file}`;

    if (reversed) cardEl.classList.add('reversed');

    const pos = slotEl.getAttribute('data-pos');
    const oriLabel = reversed ? '逆位置' : '正位置';
    const posLabel = pos === 'past' ? '過去' : pos === 'present' ? '現在' : '未来';
    const text = buildPositionText(card, pos, reversed);
    infoEl.textContent = '';

    requestAnimationFrame(() => {
      setTimeout(() => {
        cardEl.classList.add('revealed');
        infoEl.innerHTML = `<span class="name">${card.name} / ${card.en}</span><span class="ori">${oriLabel}</span>\n${posLabel}: ${text}`;
      }, Math.max(0, revealDelayMs));
    });
  }

  function getCenterRect(el) {
    const r = el.getBoundingClientRect();
    return { x: r.left + r.width / 2, y: r.top + r.height / 2, w: r.width, h: r.height };
  }

  function createFlying(fromEl, toEl) {
    const from = getCenterRect(fromEl);
    const to = getCenterRect(toEl);
    const fc = document.createElement('div');
    fc.className = 'flying-card';
    // place at from center correcting for element size
    const startX = from.x - 110; // half of 220
    const startY = from.y - 180; // half of 360
    const endX = to.x - 110;
    const endY = to.y - 180;
    fc.style.transform = `translate(${startX}px, ${startY}px)`;
    document.body.appendChild(fc);
    return new Promise(resolve => {
      let settled = false;
      requestAnimationFrame(() => {
        fc.style.transform = `translate(${endX}px, ${endY}px)`;
      });
      const done = () => {
        if (settled) return;
        settled = true;
        fc.removeEventListener('transitionend', done);
        fc.remove();
        resolve();
      };
      fc.addEventListener('transitionend', done);
      // Fallback in case transitionend doesn't fire
      setTimeout(done, 900);
    });
  }

  async function returnCardsToDeck() {
    // Determine if any slot has content to return
    const needReturn = slots.some(slot => slot.querySelector('.card').classList.contains('revealed') || slot.querySelector('.info').textContent.trim() !== '');
    if (!needReturn) return;

    // Sequentially return future -> present -> past
    for (let i = slots.length - 1; i >= 0; i--) {
      const slot = slots[i];
      const cardEl = slot.querySelector('.card');
      const infoEl = slot.querySelector('.info');
      const imgEl = slot.querySelector('.face.front img');
      const fromEl = cardEl;
      const toEl = deckEl.querySelector('.pilecard:last-child') || deckEl;
      const rectRef = cardEl; // measure before hiding
      // Hide the slot card during flight
      cardEl.classList.add('hidden');
      await createFlying(rectRef, toEl);
      // Reset slot (keep hidden so only deck remains visible)
      cardEl.classList.remove('revealed', 'reversed');
      infoEl.textContent = '';
      imgEl.src = BLANK_DATA_URI;
      await new Promise(r => setTimeout(r, 120));
    }
  }

  async function dealFromDeck(picks) {
    for (let i = 0; i < slots.length; i++) {
      const slot = slots[i];
      const cardEl = slot.querySelector('.card');
      const imgEl = slot.querySelector('.face.front img');
      const toEl = cardEl;
      const fromEl = deckEl.querySelector('.pilecard:last-child') || deckEl;
      // Prepare slot card hidden until arrival
      cardEl.classList.add('hidden');
      await createFlying(fromEl, toEl);
      // Show and reveal the actual slot card
      cardEl.classList.remove('hidden');
      // Set face and flip after a brief delay so arrival shows back first
      cardEl.classList.remove('revealed');
      imgEl.src = BLANK_DATA_URI; // ensure clean
      if (typeof setCardFaceDelayed === 'function') {
        setCardFaceDelayed(slot, picks[i], picks[i].reversed, 180);
      } else {
        setCardFace(slot, picks[i], picks[i].reversed);
      }
      await new Promise(r => setTimeout(r, 300));
    }
  }

  async function animateThreeDraw() {
    startBtn.disabled = true;

    // Return existing cards to deck with animation
    await returnCardsToDeck();
    // Brief moment where only deck is visible
    await new Promise(r => setTimeout(r, 200));

    // Draw new three from deck
    const picks = drawThree();
    await dealFromDeck(picks);

    // Re-enable shortly after
    setTimeout(() => { startBtn.disabled = false; }, 400);
  }

  // Initial: only deck visible
  (function initOnlyDeck() {
    for (const slot of slots) {
      const cardEl = slot.querySelector('.card');
      const infoEl = slot.querySelector('.info');
      const imgEl = slot.querySelector('.face.front img');
      cardEl.classList.remove('revealed', 'reversed');
      cardEl.classList.add('hidden');
      infoEl.textContent = '';
      imgEl.src = BLANK_DATA_URI;
    }
  })();

  startBtn.addEventListener('click', animateThreeDraw);
})();

